#Graph-Theory-and-Network
出題資料より抜粋

##課題1-1-1
graph1.txt にて表現される無向グラフに対し，2 次元配列adjacent[N_MAX][N_MAX]を利用して隣
接行列を格納するようなプログラムを作成せよ．

作成の条件：

(1) graph1.txt を作成し，fscanf などのファイル入力関数を利用して情報を読み込むこと．

(2) 点の数と辺の数を記憶する変数（N, M）を準備しておくこと．

(3) N_MAX は100 とすること．

(4) graph1.txt からの読み込みが正常に行われたかどうかを確認するため，adjacent 配列をprintf など
により画面表示すること．


##課題1-1-2
課題1-1-1 では配列をあらかじめ100×100 として用意しているが，点の数は7 しかなく，実際に
利用されるのは7×7 の領域のみとなり無駄が多い．そこで，1-1-1 で利用する2 次元配列を2 次元ポ
インタ変数（ int **adjacent; ）として定義し，graph1.txt の1 行目を読み込んでから必要な配列を
malloc するようにプログラムを修正せよ．

##課題1-2
graph1.txt にて表現される無向グラフに対し，隣接行列を格納する2 次元ポインタ変数adjacent を
利用して，すべての点の次数とグラフの平均次数を算出して表示するプログラムを作成せよ．

作成の条件：

課題1-1-2 で作成したプログラムを利用（拡張）すること．


##課題1-3-1
graph1.txt にて表現される無向グラフに対し，点v0 からスタートして点v6 に到着するまで隣接する
点にランダムに移動を行った場合の経路（閉路を含んでもよい）を表示するプログラムを作成せよ．

作成のヒント：

・ 現在の点をpos，移動後の点をnext とし，乱数を利用してnext を決定する．pos の初期値は0．

・ next を決定する際，接続関係がわかるように隣接行列を利用する．

・ next が6 になれば終了．そうでなければpos←next として上の処理を繰り返す．

・ drand48()関数を使うことで，0 以上1 未満の倍精度実数乱数を作成することができる．例えば，
0 以上s（整数）未満の乱数を発生させたい場合には，次式のようにする．

r = drand48() * s;

・ 乱数の初期化には，srand48()関数を使う．引数に乱数の種（正整数）を入れる．この値を変化さ
せることで，異なる乱数系列が発生する．例： srand48( 4 );

・ 乱数の種にtime()関数などを用いてはいけない．コンピュータシミュレーションでは，同じ環境
で再実験できることが重要であるので，乱数の種は自分で決めた定数を使うこと．


## 課題1-3-2
課題1-3-1 において，乱数の種を変更しながら10000 回の試行を行い，点v0 からスタートして点
v6 に到着するまでの平均移動回数を求めよ．


## 課題2-1
1. 点連結度算出プログラム（第5回講義，4 章参照）

グラフGの点連結度κ(G) は，「G＝(V, E) のすべての分離集合Xに対する要素数|X|の最小値」と
して定義される．また，「κ(G)≦δ(G)」であることから，点連結度の最大値は最小次数となる．
以上のことから，点連結度を求めるためには，以下の手順を踏めばよい．

(1) グラフGの最小次数を算出し，δとする．

(2) 変数xを定義し，x=1とする．

(3) 要素数がxとなる点の部分集合Vx⊆Vをすべて作成する．

(4) Vxのひとつでも分離集合となるならば，x が点連結度である．プログラム終了．

(5) Vxのいずれも分離集合でないならば，xを1増加させる．

(6) x = δならば点連結度はδとなり，プログラム終了．そうでなければ(3)に戻る．


上記のアルゴリズム実現するプログラムを作成し，graph2.txt とgraph3.txt にて表現されるグラフ
に対して実行せよ．点連結度と，それがわかるときの分離集合を表示すること．ただし，x =  の場合
にはその旨を表示すること．

課題作成のポイント：

(1) 辺の情報は，隣接行列adjacent[ ][ ] として記憶すること．また，第1回演習で作成した2次元ポ
インタとして定義すること（そうしないと，以下で述べるconnect_check() 関数が利用できない）．

(2) 点連結度を算出するアルゴリズムは複雑であり，任意の点数に対して算出を行うプログラムの作
成は困難である．そこで，本課題ではN=8の場合のみ算出できれば十分である．

(3) N=8の点集合Vにおいて，要素数xの部分集合Vxを作成するヒントは，以下のとおりである．

v[7] v[6] v[5] v[4] v[3] v[2] v[1] v[0] 整数表現val

0 0 0 0 0 0 0 1 1

0 0 0 0 0 0 1 0 2

0 0 0 0 0 1 0 0 4

0 0 0 0 0 1 1 1 =4+2+1=7

1 0 0 1 0 0 1 0 =128+16+2=146

0 0 1 1 1 0 0 1 =32+16+8+1=57

0 0 1 1 1 0 1 1 =32+16+8+2+1=59

・整数表現valは0以上255（28-1）以下となる．

・valから各点vi が部分集合Vx に含まれるかどうかを算出する方法は，vi=val%2i+1/2iで求めら
れる．

例： val=57の場合

v[0]=57%2/1=1 v[4]=57%32/16=1

v[1]=57%4/2=0 v[5]=57%64/32=1

v[2]=57%8/4=0 v[6]=57%128/64=0

v[3]=57%16/8=1 v[7]=57%256/127=0 ⇒ Vx={v0, v3, v4, v5}

・Σv[i] を算出すれば，要素数が得られる．

・G からVx を除去して得られるグラフG’＝V-Vx は，Vx に含まれる点番号に対応する行と列
を隣接行列adjacent[ ][ ] からすべて削除することで得られる．

(4) 分離集合であるかどうかを判断するためには，グラフG’が連結かどうかを調べる必要がある．後
述の関数int connect_check(int, int **) を利用すること．この関数はグラフの連結成分数を返す．
すなわち，連結グラフのときには1 が，非連結のときには2 以上が返される．

## 課題2-2-1
グラフがオイラーグラフであるかどうかを判定するプログラムを作成し，graph2.txt とgraph3.txt
にて表現されるグラフに対して実行せよ．


## 課題2-2-2
フラーリーのアルゴリズムによりオイラー閉路を求めるプログラムを作成し，graph2.txt と
graph3.txt にて表現されるグラフに対して実行せよ．オイラーグラフの場合には求められたオイラー
閉路を表示し，オイラーグラフでない場合にはその旨表示してプログラムを終了すること


## 課題3-1
network1.txt，及びnetwork2.txt にて表現される重み付きグラフ（ネットワーク）に対し，キーボー
ドから入力した2 点間の最短経路と最短距離を表示するプログラムをダイクストラ法により実現せよ．

課題作成のポイント：

(1) SPT の求め方は先週講義したとおりである．講義を欠席した者はS☆gsot を利用して再度学修せ
よ．

(2) 辺の情報は，隣接行列adjacent[ ][ ] と距離行列dist[ ][ ] として記憶すること．また，第1 回演習
で作成した2 次元ポインタとして定義すること．

(3) 重み付きグラフを示すファイルは，以下のように記述されている．


## 課題3-2
network1.txt，及びnetwork2.txt にて表現される重み付きグラフ（ネットワーク）に対し，Prim 法
を用いてMST を求めるプログラムを実現せよ．出力として，MST に含まれる辺の情報（両端の点番
号）を画面表示すること．

(1) 辺の情報は，隣接行列adjacent[ ][ ] と距離行列dist[ ][ ] として記憶すること．また，第1 回演習
で作成した2 次元ポインタとして定義すること．

(2) Prim 法を用いること．

## 課題4-1
network3.txt 及びnetwork4.txt にて表現される有向重み付きグラフに対し，点s から点t への最大フ
ローを求めるプログラムを作成せよ．

課題作成のポイント：

(1) プログラムの骨子を提示するので，それを利用すること．

(2) 最大フローを求めるアルゴリズムとして，フォード・ファルカーソン法を利用すること．フォー
ド・ファルカーソン法については，第11 回講義で説明したとおりである．講義を欠席した者はl や
S☆gsot を利用して再度学修すること．

(3) 有向重み付きグラフを示すファイルは，以下のように記述されている．有向辺であることに十分
注意すること．例えば，2 行目が表す意味は，「点0 から点2 の方向へ容量が21」であることを
示すものであり，点2 から点0 への有向辺は存在しないことに注意せよ．

(4) 辺の情報は，隣接行列adjacent[ ][ ] として記憶すること．また，第1 回演習で作成した2 次元ポ
インタとして定義すること．フロー増加道探索のため，「点0 から点2 の方向への辺」を記憶する
際もadjacent[0][2] = 1, adjacent[2][0] = 1 としておくこと（辺の向きは，(5) のcapacity[][] 配列に
より判別可能である）．

(5) 辺容量は，2 次元整数型配列capacity[][] として記憶すること．本課題では有向辺を取り扱うので，
「点0 から点2 の方向へ容量が21」の場合，capacity[0][2] = 21 とすればよい．もし，逆方向の
辺が存在しない場合には，capacity[2][0] = 0 となる．

(6) 辺のフローも同様に，2 次元整数型配列flow[][] として記憶すること．辺容量と同様に，「点0 か
ら点2 の方向へフローが5」の場合，flow[0][2] = 5 とすればよい．

(7) フロー増加道を見つけるために，深さ優先探索を利用すること．すなわち，第2 回演習で配布し
たconnect_check() 関数を流用し，フローの増加が可能な辺のみを対象として深さ優先探索を実
施すればよい．

(8) いくつかの実行結果を提出すること．その際，(s,t)=(0, 3), (3, 5), (7, 8) の結果を必ず提出するこ
と．


## 課題4-2（応用課題）
フロー増加道を探す場合，できるだけ短い経路を利用するほうが，アルゴリズムの効率がよい．そ
こで，課題4-1 において，フロー増加道の探索に幅優先探索を用いたプログラムを作成せよ．

(1) 幅優先探索は第8 回講義で説明したとおりである．講義を欠席した者はminetel やS☆gsot を利
用して再度学修せよ．

(2) 任意の2点間の道を探索するためには，始点s に対して幅優先探索を実施し，幅優先探索木WFS(s)
（s を根としたWFS）を作成すればよい．木の状態を保持するためには，ダイクストラのアルゴ
リズムと同様にfather[] 配列を用いる．

(3) 辺の情報は，隣接行列adjacent[][] として記憶すること．また，第1 回演習で作成した2 次元ポ
インタとして定義すること．

(4) 第2 回演習時に配布したconnect_check() 及びvisit() は，深さ優先探索によりグラフの連結性を
求める関数であるので，参考になるであろう．深さ優先探索では，隣接する点を1 個見つけるた
びにvisit() 関数を再帰的に呼び出すが，幅優先探索の場合には，隣接するすべての点を見つけて
から，（それらの点集合とともに）visit() 関数を呼び出す必要があることに注意せよ．
